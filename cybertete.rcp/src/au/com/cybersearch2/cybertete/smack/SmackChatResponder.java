/**
    Copyright (C) 2016  www.cybersearch2.com.au

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/> */
package au.com.cybersearch2.cybertete.smack;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.annotation.PostConstruct;
import javax.inject.Inject;

import org.eclipse.e4.core.di.annotations.Creatable;
import org.jivesoftware.smack.chat.Chat;
import org.jivesoftware.smack.chat.ChatManagerListener;
import org.jivesoftware.smack.chat.ChatMessageListener;
import org.jivesoftware.smack.packet.Message;
import org.jxmpp.util.XmppStringUtils;

import au.com.cybersearch2.cybertete.model.ChatContacts;
import au.com.cybersearch2.cybertete.model.ContactEntry;
import au.com.cybersearch2.cybertete.model.ContactsTree;
import au.com.cybersearch2.cybertete.model.internal.ContactEntryList;
import au.com.cybersearch2.cybertete.model.service.ChatListener;
import au.com.cybersearch2.cybertete.service.ChatContactListener;
import au.com.cybersearch2.cybertete.service.SessionOwner;

/**
 * SmackChatResponder
 * Listens for Chat events generated by Smack library and responds
 * by creating new Chat sessions or dispatching messages depending on event type.
 * @author Andrew Bowley
 * 3 Apr 2016
 */
@Creatable
public class SmackChatResponder implements ChatContacts, ChatManagerListener, ChatMessageListener
{
    /** Map each Smack Chat object to a ContactEntry object */
    Map<Chat, ContactEntry> chatMap;

    /** Sends text messages to Chat windows */
    @Inject
    ChatContactListener chatContactListener;

    /** Container of roster contacts kept in sync with master located at the Chat server */
    @Inject
    ContactsTree contactsTree;
    /** Contact entry of logged in user */
    @Inject
    SessionOwner sessionOwner;
    /** Establishes a Chat window for specified contact */
    @Inject
    ChatListener chatListener;

    /**
     * Post construct
     */
    @PostConstruct
    public void postConstruct()
    {
        chatMap = new ConcurrentHashMap<Chat, ContactEntry>();
    }

    /**
     * Returns flag set true if contact is engaged in a chat session
     * @param participant Contact entry 
     * @return boolean
     */
    @Override
    public boolean chatExists(ContactEntry participant)
    {   // Linear search should not take long as number of simultaneous chat sessions
        // is expected to be small. 
        return chatMap.values().contains(participant);
    }

    /**
     * Clear all Chat sessions
     */
    public void close()
    {
        for (Chat chat: chatMap.keySet())
            chat.close();
        chatMap.clear();
    }

    /**
     * Event fired when a new chat is created.
     * @param chat The chat that was created.
     * @param createdLocally Flag set true if the chat was created by the local user
     * @see org.jivesoftware.smack.chat.ChatManagerListener#chatCreated(org.jivesoftware.smack.chat.Chat, boolean)
     */
    @Override
    public void chatCreated(Chat chat, boolean createdLocally)
    {
        if (!createdLocally)
        {   // Remote chat messages are discarded until one with a body is received
            chat.addMessageListener(new ChatMessageListener() {

                @Override
                public void processMessage(Chat chat,
                        Message message)
                {   // Only packet with message body is relevant
                    if (message.getBody() == null)
                        return;
                    chat.removeMessageListener(this);
                    onStartChat(chat, message.getBody());
                }});
        }
    }

    /**
     * Process incoming Chat message
     * @see org.jivesoftware.smack.chat.ChatMessageListener#processMessage(org.jivesoftware.smack.chat.Chat, org.jivesoftware.smack.packet.Message)
     */
    @Override
    public void processMessage(Chat chat, Message message)
    {
        String body = message.getBody();
        if (body != null)
        {
            ContactEntry participant = chatMap.get(chat);
            if (participant != null)
                chatContactListener.onMessageReceived(participant, body);
        }
    }

    /**
     * Establish new Chat session
     * @param chat Chat object provided by Smack library
     * @param body Body of incoming chat packet or null if locally initiated Chat 
     */
    void onStartChat(Chat chat, String body)
    {
        // Find participant's ContactEntry in the roster
        String participant = XmppStringUtils.parseBareJid(chat.getParticipant());
        // Try to match to session owner's group, otherwise just use head entry.
        ContactEntryList contactEntryList = contactsTree.getContactEntryList(participant);
        if (contactEntryList != null)
        {
            ContactEntry contactEntry = contactEntryList.getEntryByGroup(sessionOwner.getContact().getParent().getName());
            if (contactEntry == null)
                contactEntry = contactEntryList.getHead();
            onStartChat(chat, contactEntry, body); 
        }
    }
    
    /**
     * Establish new Chat session
     * @param chat Chat object provided by Smack library
     * @param body Body of incoming chat packet or null if locally initiated Chat 
     */
    void onStartChat(Chat chat, ContactEntry contact, String body)
    {
        // Check contact is found and chat is unique (identified by combination of participant and thread ID)
        if ((contact != null) && !chatMap.containsKey(chat))
        {
            chatMap.put(chat, contact);
            SmackChatSession chatSession = new SmackChatSession(chat, contact, sessionOwner.getContact());
            chatListener.onStartChat(chatSession, contact, body);
            chat.addMessageListener(this);
        }
        // TODO - Report incoming Chat already exists for this participant. Same person, different resource?
        // TODO - Report incoming Chat roster entry not found
    }

}
